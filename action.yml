name: 'Sync Repository Content'
description: 'Sync content from another repository with ignore patterns and create a PR'
author: 'Your Name'

branding:
  icon: 'git-pull-request'
  color: 'blue'

inputs:
  source-repo:
    description: 'Source repository (format: owner/repo)'
    required: true
  source-branch:
    description: 'Source branch to sync from'
    required: false
    default: 'main'
  source-path:
    description: 'Source path to sync (leave empty for root)'
    required: false
    default: ''
  target-path:
    description: 'Target path in the destination repository'
    required: false
    default: ''
  ignore-patterns:
    description: 'Patterns to ignore during sync (newline-separated)'
    required: false
  pr-title:
    description: 'Pull Request title (auto-generated if not provided)'
    required: false
    default: ''
  pr-body:
    description: 'Pull Request body'
    required: false
    default: ''
  branch-prefix:
    description: 'Prefix for the sync branch'
    required: false
    default: 'sync'
  commit-message:
    description: 'Custom commit message'
    required: false
    default: ''
  github-token:
    description: 'GitHub token for authentication (needs access to both source and target repos)'
    required: true
  create-pr:
    description: 'Whether to create a pull request'
    required: false
    default: 'true'
  delete-obsolete:
    description: 'Delete files in target that dont exist in source'
    required: false
    default: 'false'
  sync-mode:
    description: 'Sync mode: update (only update existing files and add new ones) or replace (full sync)'
    required: false
    default: 'update'
  git-user-name:
    description: 'Git user name for commits'
    required: false
    default: 'github-actions[bot]'
  git-user-email:
    description: 'Git user email for commits'
    required: false
    default: 'github-actions[bot]@users.noreply.github.com'

outputs:
  pr-url:
    description: 'URL of the created pull request'
    value: ${{ steps.create-pr.outputs.pr_url }}
  pr-number:
    description: 'Number of the created pull request'
    value: ${{ steps.create-pr.outputs.pr_number }}
  has-changes:
    description: 'Whether changes were detected'
    value: ${{ steps.sync.outputs.has_changes }}
  branch-name:
    description: 'Name of the created branch'
    value: ${{ steps.sync.outputs.branch_name }}
  pr-skipped:
    description: 'Whether PR creation was skipped due to duplicate'
    value: ${{ steps.create-pr.outputs.pr_skipped }}
  skip-reason:
    description: 'Reason for skipping PR creation'
    value: ${{ steps.create-pr.outputs.skip_reason }}

runs:
  using: 'composite'
  steps:
    - name: Checkout current repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ inputs.github-token }}

    - name: Setup Git
      shell: bash
      run: |
        git config --global user.name "${{ inputs.git-user-name }}"
        git config --global user.email "${{ inputs.git-user-email }}"

    - name: Run sync script
      id: sync
      shell: bash
      env:
        SOURCE_REPO: ${{ inputs.source-repo }}
        SOURCE_BRANCH: ${{ inputs.source-branch }}
        SOURCE_PATH: ${{ inputs.source-path }}
        TARGET_PATH: ${{ inputs.target-path }}
        IGNORE_PATTERNS: ${{ inputs.ignore-patterns }}
        BRANCH_PREFIX: ${{ inputs.branch-prefix }}
        COMMIT_MESSAGE: ${{ inputs.commit-message }}
        DELETE_OBSOLETE: ${{ inputs.delete-obsolete }}
        SYNC_MODE: ${{ inputs.sync-mode }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        set -e
        
        # Setup git config with --global flag
        git config --global user.name "${{ inputs.git-user-name }}"
        git config --global user.email "${{ inputs.git-user-email }}"
        
        # Verify we're in the correct repository
        echo "Current repository remote URL:"
        git remote -v
        
        # Create branch
        BRANCH_NAME="${BRANCH_PREFIX}-$(date +%Y%m%d-%H%M%S)"
        echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
        git checkout -b $BRANCH_NAME
        
        # Verify branch was created successfully
        CURRENT_BRANCH=$(git branch --show-current)
        if [ "$CURRENT_BRANCH" != "$BRANCH_NAME" ]; then
          echo "Error: Failed to create or switch to branch $BRANCH_NAME"
          echo "Current branch is: $CURRENT_BRANCH"
          exit 1
        fi
        echo "Successfully switched to branch: $BRANCH_NAME"
        
        # Clone source repository with proper authentication
        echo "Cloning source repository: $SOURCE_REPO"
        # Try with token first, fallback to public access if it fails
        if [ -n "$GITHUB_TOKEN" ] && git clone --depth 10 --branch $SOURCE_BRANCH https://x-access-token:${GITHUB_TOKEN}@github.com/$SOURCE_REPO.git /tmp/source-repo 2>/dev/null; then
          echo "Cloned using provided token"
        else
          echo "Attempting public access..."
          if ! git clone --depth 10 --branch $SOURCE_BRANCH https://github.com/$SOURCE_REPO.git /tmp/source-repo 2>/dev/null; then
            echo "Error: Failed to clone repository. If this is a private repository, please ensure a valid GitHub token is provided."
            exit 1
          fi
          echo "Cloned using public access"
        fi
        
        # Get the latest commit message from source repo
        LATEST_COMMIT_MSG=$(cd /tmp/source-repo && git log -1 --pretty=format:"%s")
        LATEST_COMMIT_SHA=$(cd /tmp/source-repo && git log -1 --pretty=format:"%h")
        echo "latest_commit_msg=$LATEST_COMMIT_MSG" >> $GITHUB_OUTPUT
        echo "latest_commit_sha=$LATEST_COMMIT_SHA" >> $GITHUB_OUTPUT
        
        # Prepare paths
        if [ -n "$SOURCE_PATH" ]; then
          SOURCE_DIR="/tmp/source-repo/$SOURCE_PATH"
        else
          SOURCE_DIR="/tmp/source-repo"
        fi
        
        if [ -n "$TARGET_PATH" ] && [ "$TARGET_PATH" != "." ]; then
          mkdir -p "$TARGET_PATH"
        fi
        
        # Create exclude file - always exclude .git directory
        echo ".git/" > /tmp/rsync-exclude.txt
        echo "$IGNORE_PATTERNS" >> /tmp/rsync-exclude.txt
        
        # Prepare rsync options based on sync mode
        if [ "$SYNC_MODE" == "update" ]; then
          # Update mode: only update existing files and add new ones, don't delete
          RSYNC_OPTS="-av --update"
          echo "Using UPDATE mode: Only updating changed files and adding new files from template"
        else
          # Replace mode: full sync
          RSYNC_OPTS="-av"
          if [ "$DELETE_OBSOLETE" == "true" ]; then
            RSYNC_OPTS="$RSYNC_OPTS --delete"
            echo "Using REPLACE mode with delete: Full sync with deletion of obsolete files"
          else
            echo "Using REPLACE mode: Full sync without deletion"
          fi
        fi
        
        # Sync files
        echo "Current branch before rsync: $(git branch --show-current)"
        echo "Syncing files with rsync options: $RSYNC_OPTS"
        rsync $RSYNC_OPTS \
          --exclude-from=/tmp/rsync-exclude.txt \
          "$SOURCE_DIR/" \
          "${TARGET_PATH:-.}/"
        echo "Current branch after rsync: $(git branch --show-current)"
        
        # Check for changes
        if git diff --quiet && git diff --staged --quiet; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "No changes detected"
        else
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "Changes detected"
          git add -A
          
          # Verify we're on the correct branch before committing
          echo "Current branch before commit: $(git branch --show-current)"
          
          # Commit changes
          if [ -n "$COMMIT_MESSAGE" ]; then
            git commit -m "$COMMIT_MESSAGE"
          else
            git commit -m "Sync content from $SOURCE_REPO
        
        Source: https://github.com/$SOURCE_REPO
        Branch: $SOURCE_BRANCH
        Path: ${SOURCE_PATH:-root}
        
        Ignored patterns applied:
        $(echo "$IGNORE_PATTERNS" | sed 's/^/  - /')"
          fi
          
          # Ensure we're pushing to the correct repository
          # GitHub Actions sets GITHUB_REPOSITORY as owner/repo format
          CURRENT_REPO="${GITHUB_REPOSITORY}"
          echo "Pushing to repository: $CURRENT_REPO"
          echo "Pushing branch: $BRANCH_NAME"
          echo "Current branch: $(git branch --show-current)"
          
          # Reset remote URL to current repository
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${CURRENT_REPO}.git"
          echo "Remote URL after reset:"
          git remote -v
          
          # Push changes to the current repository
          git push -u origin $BRANCH_NAME
        fi

    - name: Create Pull Request
      id: create-pr
      if: ${{ inputs.create-pr == 'true' && steps.sync.outputs.has_changes == 'true' }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const sourceRepo = '${{ inputs.source-repo }}';
          const sourceBranch = '${{ inputs.source-branch }}';
          const sourcePath = '${{ inputs.source-path }}' || 'root';
          const targetPath = '${{ inputs.target-path }}' || 'root';
          const latestCommitMsg = ${{ toJSON(steps.sync.outputs.latest_commit_msg) }};
          const latestCommitSha = '${{ steps.sync.outputs.latest_commit_sha }}';
          const branchName = '${{ steps.sync.outputs.branch_name }}';
          
          // Extract repo name from owner/repo format
          const repoName = sourceRepo.split('/')[1];
          
          // Use custom PR title if provided, otherwise use the new format
          let prTitle = ${{ toJSON(inputs.pr-title) }};
          if (!prTitle || prTitle === 'Sync content from upstream repository') {
            prTitle = `[Sync Bot] Synchronized ${repoName}: ${latestCommitMsg}`;
          } else {
            // Add [Sync Bot] prefix if not already present
            if (!prTitle.startsWith('[Sync Bot]')) {
              prTitle = `[Sync Bot] ${prTitle}`;
            }
          }
          
          // Check for existing open PRs with the same changes
          console.log('Checking for existing open PRs...');
          console.log(`Looking for PRs from source: ${sourceRepo}`);
          
          // Get all open PRs
          const openPRs = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            base: context.payload.repository.default_branch,
          });
          
          console.log(`Found ${openPRs.data.length} open PRs to check`);
          
          // Check if there's already a PR from a sync branch with similar title
          const existingPR = openPRs.data.find(pr => {
            // Check if it's a sync bot PR
            if (!pr.title.startsWith('[Sync Bot]')) {
              return false;
            }
            
            // Check if it's from the same source repository
            if (pr.title.includes(repoName)) {
              console.log(`Found PR with matching repo name in title: #${pr.number}`);
              return true;
            }
            
            // Also check the body for source repository information (various formats)
            if (pr.body) {
              // Check for different possible formats in PR body
              const bodyContainsRepo = 
                pr.body.includes(`[${sourceRepo}]`) ||
                pr.body.includes(`${sourceRepo}`) ||
                pr.body.includes(`Repository**: [${sourceRepo}]`) ||
                pr.body.includes(`**Repository**: [${sourceRepo}]`);
              
              if (bodyContainsRepo) {
                console.log(`Found PR with matching repo in body: #${pr.number}`);
                return true;
              }
            }
            
            // Also check if the PR branch starts with the same prefix pattern
            if (pr.head && pr.head.ref) {
              const isSyncBranch = pr.head.ref.startsWith('sync-');
              if (isSyncBranch && pr.body && pr.body.includes(sourceRepo)) {
                console.log(`Found sync branch PR with matching source: #${pr.number}`);
                return true;
              }
            }
            
            return false;
          });
          
          // If no existing PR found by title/body, check commit messages for source repo
          let finalExistingPR = existingPR;
          if (!finalExistingPR) {
            console.log('No PR found by title/body check. Checking commit messages...');
            
            // Check PRs with sync branches for commit messages
            for (const pr of openPRs.data) {
              if (pr.head && pr.head.ref && pr.head.ref.startsWith('sync-')) {
                try {
                  // Get commits from the PR
                  const commits = await github.rest.pulls.listCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                  });
                  
                  // Check if any commit message mentions the source repo
                  const hasSourceRepo = commits.data.some(commit => 
                    commit.commit.message.includes(sourceRepo) ||
                    commit.commit.message.includes(`Sync content from ${sourceRepo}`)
                  );
                  
                  if (hasSourceRepo) {
                    console.log(`Found PR #${pr.number} with matching source in commit messages`);
                    finalExistingPR = pr;
                    break;
                  }
                } catch (error) {
                  console.log(`Could not check commits for PR #${pr.number}: ${error.message}`);
                }
              }
            }
          }
          
          if (finalExistingPR) {
            console.log(`Found existing PR #${finalExistingPR.number}: ${finalExistingPR.title}`);
            
            // Compare the actual changes each PR would introduce to the base branch
            try {
              const baseBranch = context.payload.repository.default_branch;
              
              // Get the diff of the existing PR against base
              console.log(`Comparing existing PR branch (${finalExistingPR.head.ref}) with base (${baseBranch})`);
              const existingPRDiff = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: baseBranch,
                head: finalExistingPR.head.ref,
              });
              
              // Get the diff of the new branch against base
              console.log(`Comparing new branch (${branchName}) with base (${baseBranch})`);
              const newBranchDiff = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: baseBranch,
                head: branchName,
              });
              
              // Compare the file changes
              const existingFiles = new Set(existingPRDiff.data.files.map(f => `${f.filename}:${f.sha}`));
              const newFiles = new Set(newBranchDiff.data.files.map(f => `${f.filename}:${f.sha}`));
              
              // Check if the changes are identical
              const areIdentical = existingFiles.size === newFiles.size && 
                [...existingFiles].every(file => newFiles.has(file));
              
              if (areIdentical) {
                console.log('The changes are identical to the existing PR. Skipping PR creation.');
                console.log(`Existing PR URL: ${finalExistingPR.html_url}`);
                core.setOutput('pr_url', finalExistingPR.html_url);
                core.setOutput('pr_number', finalExistingPR.number);
                core.setOutput('pr_skipped', 'true');
                core.setOutput('skip_reason', 'duplicate');
                
                // Clean up the branch we just created since we don't need it
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${branchName}`,
                  });
                  console.log(`Deleted unnecessary branch: ${branchName}`);
                } catch (error) {
                  console.log(`Could not delete branch ${branchName}: ${error.message}`);
                }
                
                return;
              } else {
                console.log(`Different changes detected:`);
                console.log(`- Existing PR has ${existingFiles.size} file changes`);
                console.log(`- New branch has ${newFiles.size} file changes`);
                
                // Show what's different
                const onlyInExisting = [...existingFiles].filter(f => !newFiles.has(f));
                const onlyInNew = [...newFiles].filter(f => !existingFiles.has(f));
                
                if (onlyInExisting.length > 0) {
                  console.log(`Files only in existing PR: ${onlyInExisting.map(f => f.split(':')[0]).join(', ')}`);
                }
                if (onlyInNew.length > 0) {
                  console.log(`Files only in new branch: ${onlyInNew.map(f => f.split(':')[0]).join(', ')}`);
                }
                
                console.log('Creating new PR with different changes.');
              }
            } catch (error) {
              console.log(`Could not compare branches: ${error.message}`);
              console.log('Proceeding with PR creation...');
            }
          } else {
            console.log('No existing PR found. Creating new PR...');
          }
          
          let prBody = ${{ toJSON(inputs.pr-body) }};
          if (!prBody) {
            // Use JSON parsing to handle multiline strings safely
            const ignorePatterns = ${{ toJSON(inputs.ignore-patterns) }};
            const patternsList = ignorePatterns ? ignorePatterns.split('\n').filter(p => p.trim()).map(p => `- \`${p}\``).join('\n') : '- None';
            
            prBody = `## 📋 Summary
          
          This PR syncs content from the upstream repository.
          
          ### Source Information
          - **Repository**: [${sourceRepo}](https://github.com/${sourceRepo})
          - **Branch**: \`${sourceBranch}\`
          - **Latest Commit**: \`${latestCommitSha}\` - ${latestCommitMsg}
          - **Source Path**: \`${sourcePath}\`
          - **Target Path**: \`${targetPath}\`
          
          ### Ignored Patterns
          The following patterns were excluded from sync:
          ${patternsList}
          
          ### Changes
          Please review the changes in the Files changed tab.
          
          ---
          *This PR was automatically created by the sync-repository action.*`;
          }
          
          const pr = await github.rest.pulls.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: prTitle,
            body: prBody,
            head: branchName,
            base: context.payload.repository.default_branch,
          });
          
          console.log(`Pull request created: ${pr.data.html_url}`);
          core.setOutput('pr_url', pr.data.html_url);
          core.setOutput('pr_number', pr.data.number);
          core.setOutput('pr_skipped', 'false');